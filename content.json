{"meta":{"title":"Ruoduan's Blog","subtitle":"人生如逆旅，我亦是行人。","description":"人非圣贤，都会留恋这个花花世界，坚其本心方得始终","author":"Ruoduan","url":"https://www.ruoduan.top"},"pages":[{"title":"留言板","date":"2018-11-08T10:38:13.000Z","updated":"2019-01-12T12:15:20.219Z","comments":true,"path":"tags/index.html","permalink":"https://www.ruoduan.top/tags/index.html","excerpt":"","text":"致辞：​重要的事往往最难以启齿，因为言语会缩小其重要性；要让素昧平生的人在意你生命中的美好事物，原本就不容易。 ​ ——《肖申克的救赎》"},{"title":"About me","date":"2018-11-08T10:40:30.000Z","updated":"2019-01-12T12:01:26.326Z","comments":true,"path":"about/index.html","permalink":"https://www.ruoduan.top/about/index.html","excerpt":"","text":"南渡。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从南而来，不为渡人只为渡己。 E-mail: chad97@126.com"},{"title":"分类页","date":"2018-11-08T10:38:13.000Z","updated":"2019-01-12T09:05:02.150Z","comments":true,"path":"categories/index.html","permalink":"https://www.ruoduan.top/categories/index.html","excerpt":"","text":"分类页"}],"posts":[{"title":"path模块的__dirname和__filename","slug":"path模块的-dirname和-filename","date":"2019-01-26T08:20:33.000Z","updated":"2019-01-26T08:22:31.209Z","comments":true,"path":"2019/01/26/path模块的-dirname和-filename/","link":"","permalink":"https://www.ruoduan.top/2019/01/26/path模块的-dirname和-filename/","excerpt":"","text":"nodejs ——path模块的dirname 和 filename 我们在使用nodejs，可能需要对 node_modules 开放一些目录，fs 取的是绝对路径，而我们在不同的环境下，node_modules 可能存在于 不同的 根目录中，这个时候我们就要用到 join（）方法 来吧绝对路径进行一个转换，来获取一个动态的绝对路径 12app.use('/public/', express.static(path.join(__dirname, './public/')))app.use('/node_modules/', express.static(path.join(__dirname, './node_modules/'))) 这里我们开放了 public和node_modules 这2个 目录文件夹 dirname 和 filename 动态的 获取当前文件或者文件所处目录的绝对路径 用来解决文件操作路劲的相对路径问题 因为在文件操作中，相对路径相对于执行 node 命令所处的目录 所以为了尽量避免这个问题，都建议文件操作的相对路径都转为：动态的绝对路径 方式：path.join(__dirname, &#39;文件名&#39;) dirname 和 filename 是模块中 的一个内置成员，他们分别是： __dirname 是当前文件夹的绝对路径 __filename是当前文件的绝对路径 一般情况下都是 配合 join方法使用的，把当前相对路径转换为 动态的绝对路径","categories":[{"name":"《Nodejs》","slug":"《Nodejs》","permalink":"https://www.ruoduan.top/categories/《Nodejs》/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.ruoduan.top/tags/Nodejs/"}]},{"title":"canvas穿透pointer-events属性","slug":"canvas穿透pointer-events属性","date":"2019-01-18T07:03:19.000Z","updated":"2019-01-18T07:08:03.260Z","comments":true,"path":"2019/01/18/canvas穿透pointer-events属性/","link":"","permalink":"https://www.ruoduan.top/2019/01/18/canvas穿透pointer-events属性/","excerpt":"","text":"遇到这个问题这里记录一下，解决方案也非常简单 在我们把 canvas 作为 网站的 body 背景的 时候，如果z-index 的层级没注意设计，默认情况下，canvas 会遮挡网站上的 a 链接 和一些按钮的 遇到这个 问题 我们只需要在 canvas 背景中添加一个css 属性：pointer-events: none 你可以选择后期用 js 添加，也可以在创建的 时候直接写上，如果是canvas 在本地 可以直接写上，如果是请求而来的，可以用js 给相应的 canvas 添加这一条属性 语法 pointer-events：auto | none | visiblepainted | visiblefill | visiblestroke | visible | painted | fill | stroke | all 默认值：auto 取值 auto： 与pointer-events属性未指定时的表现效果相同。在svg内容上与visiblepainted值相同 none：元素永远不会成为鼠标事件的target。但是，当其后代元素的pointer-events属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶触发父元素的事件侦听器。其他值只能应用在SVG上。 说明：设置或检索在何时成为属性事件的target。使用pointer-events来阻止元素成为鼠标事件目标不一定意味着元素上的事件侦听器永不会触发。如果元素后代明确指定了pointer-events属性并允许其成为鼠标事件的目标，那么指向该元素的任何事件在事件传播过程中都将通过父元素，并以适当的方式触发其上的事件侦听器。当然位于屏幕上在父元素上但不在后代元素上的鼠标活动都不会被父元素和后代元素捕获（将会穿过父元素而指向位于其下面的元素）。对应的脚本特性为pointerEvents。 小栗子123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-cmn-Hans\"&gt;&lt;head&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;pointer-events_CSS参考手册_web前端开发参考手册系列&lt;/title&gt;&lt;style&gt;a[href=\"http://example.com\"] &#123; pointer-events: none;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=\"https://developer.mozilla.org/\"&gt;MDN&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"http://example.com\"&gt;一个不能点击的链接&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 参考链接 结束啦~","categories":[{"name":"《Front-end》","slug":"《Front-end》","permalink":"https://www.ruoduan.top/categories/《Front-end》/"}],"tags":[{"name":"Front-end","slug":"Front-end","permalink":"https://www.ruoduan.top/tags/Front-end/"}]},{"title":"promise解决回调地狱(callback-hell)","slug":"promise解决回调地狱-callback-hell","date":"2019-01-12T08:20:25.000Z","updated":"2019-01-12T08:55:29.229Z","comments":true,"path":"2019/01/12/promise解决回调地狱-callback-hell/","link":"","permalink":"https://www.ruoduan.top/2019/01/12/promise解决回调地狱-callback-hell/","excerpt":"","text":"具体参考 阮一峰,ES6标准入门 在我们需要对一个异步操作进行频繁的调用的时候，且要保证一步操作的顺序，可能会出现 回调地狱（callback）的情况 例如： 12345678910111213141516171819202122var fs = require('fs')fs.readFile('../data/a.txt','utf8',function (err,data) &#123; if (err) &#123; throw err &#125; console.log(data) fs.readFile('../data/b.txt','utf8',function (err,data) &#123; if (err) &#123; throw err &#125; console.log(data) fs.readFile('../data/c.txt','utf8',function (err,data) &#123; if (err) &#123; throw err &#125; console.log(data); &#125;) &#125;)&#125;) 解决这个问题让我们的代码看起来更加直观，我们可以用promise 解决这个问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var p1 = new Promise(function (resolve,reject) &#123; fs.readFile('../data/a.txt','utf8',function (err,data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;)var p2 = new Promise(function (resolve,reject) &#123; fs.readFile('../data/b.txt','utf8',function (err,data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;)var p3 = new Promise(function (resolve,reject) &#123; fs.readFile('../data/c.txt','utf8',function (err,data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;)&#125;)//console.log(p1) //Promise &#123; &lt;pending&gt; &#125;p1.then(function (data) &#123; console.log(data)//读取成功 return p2 //把下一个要读取的promise返回 &#125;,function (err) &#123; //第二个参数表示读取失败 reject 拒绝了 console.log(err+'p1失败'); &#125;) .then(function (data) &#123; console.log(data); return p2 &#125;,function (err) &#123; console.log(err+'p2失败'); &#125;) .then(function (data) &#123; console.log(data); &#125;,function (err) &#123; console.log(err+'p3失败'); &#125;) // 这样子就实现了promise 链式编程，但是重复的代码太多， //下面稍微改造一下封装一个方法 但是这样子的代码复用太多，我们可以给他稍微封装一下12345678910111213141516171819202122232425262728293031323334var fs = require('fs')function PreadFile (filePath) &#123; return new Promise(function (resolve,reject) &#123; fs.readFile(filePath,'utf8',function (err,data) &#123; if (err) &#123; reject(err) &#125; else &#123; resolve(data) &#125; &#125;) &#125;)&#125;PreadFile('../data/a.txt') .then(function (data) &#123; console.log(data) return PreadFile('../data/b.txt') &#125;,function (err) &#123; console.log(err+'a文件失败') &#125;) .then(function (data) &#123; console.log(data) return PreadFile('../data/c.txt') &#125;,function (err) &#123; console.log(err+'b文件失败') &#125;) .then(function (data) &#123; console.log(data) &#125;,function (err) &#123; console.log(err+'c文件失败') &#125;) 输出：a b c ，当然 这里的 function 用箭头函数代替更简洁，但涉及我书写blog的前后顺序和结构进性，在写es6前就尽量不使用es6语法糖 总结 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。","categories":[{"name":"《ECMA JavaScript》","slug":"《ECMA-JavaScript》","permalink":"https://www.ruoduan.top/categories/《ECMA-JavaScript》/"}],"tags":[{"name":"ECMA-JavaScript","slug":"ECMA-JavaScript","permalink":"https://www.ruoduan.top/tags/ECMA-JavaScript/"}]},{"title":"nosql数据库-mongodb使用gongoos的CRUD","slug":"nosql数据库-mongodb使用gongoos的CRUD","date":"2019-01-10T12:20:33.000Z","updated":"2019-01-10T12:36:44.750Z","comments":true,"path":"2019/01/10/nosql数据库-mongodb使用gongoos的CRUD/","link":"","permalink":"https://www.ruoduan.top/2019/01/10/nosql数据库-mongodb使用gongoos的CRUD/","excerpt":"","text":"简介NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 具体链接： 菜鸟教程 第一步下载：【下载地址】：https://www.mongodb.com/download-center/community 根据自己的操作系统和需求下载：我这里选择的是社区版的 下载完成后点击安装： 完成安装顾名思义 next 就完了 我这里选择的自定义安装 看看有哪些东西 next 选择相应的安装文件夹，这里的安装路径在后面配置 环境变量的时候要用到 一直next 安装完成后 我们用 命令行 看一下 有没有安装成功 用mongod – vesrion 可以看到 并没有 显示版本号 ，因为我们还没有配置环境变量，下面来配置一下环境变量 配置环境变量 打开安装路径找到bin 的路径复制 找到系统-环境变量 现在我们再来 mongod -version 好了 到这一步 就说明 我们的 mongodb 安装成功了 开启和停止mongodb 数据库和其他 sql 系列数据库有些不同，他在安装成功后，在我我们的服务列表是没有的，需要我们去手动安装，已达到 点击完成启动和停止的效果安装服务的 方法 具体参考菜鸟教程 ：http://www.runoob.com/mongodb/mongodb-window-install.html 我这里就是一把梭 /手动狗头~ 但是：这边并不影响我们的使用 我们可以通过命令行来启动和停止他 —— 非常简单服务启动命令：mongod停止：直接 Ctrl+C or 关闭窗口ps： 这里有个注意点： mongodb 默认使用mongod 命令所在的盘符的磁盘更目录作为自己的数据存储目录也就是目录盘符/data/db 第一次启动所以在第一次启动的时候要去 手动创建一个 data/db 这样的数据存储目录 当然我们也可以手动 修改 默认数据储存目录1mongod --dbpath=数据储存目录 连接和退出数据库12345#先启动数据库mongod#再开启一个控制台mongo 退出：exit 就可以了 基本命令 show dbs 查看显示所有数据库默认有一个admin和local 系统自带的 db 查看当前操作的数据库 use 数据库名字 切换到指定数据库（如果没有会新建） ps：如果数据库里面没有数据 show db 是看不到这个数据库的 插入数据 123456789# 插入一条 集为students的数据db.students.insertOne(&#123;\"id\":\"1\",\"name\":\"Tom\"&#125;).students.insert#查看当前集 show collections#查看当前集下面对 所有数据&gt; db.students.find()&gt; 如下：&#123; \"_id\" : ObjectId(\"5c2e19bf5d2f7705c12fcb62\"), \"id\" : \"1\", \"name\" : \"Tom\" &#125; 当然这边的操作 只是一个初体验，我们在真正使用的时候是不会用这种方式去使用的，用一些语言 例如nodejs Ruby 等一些 语言来实现 CRUD 的操作 下面我们使用 mongoose 进行一些简单的CRUD Nodejs-mongodb，mongoose的CRUD前言 设计集合结构（表结构） 字段名称就是表结构的属性名称 约束的目的就是为了保证字段的完整性，不要有脏数据 接上一篇 https://blog.csdn.net/Chad97/article/details/85720537 官方API 官方案例1234567891011121314var mongoose = require('mongoose');//官方案例var Schema = mongoose.Schema;var blogSchema = new Schema(&#123; title: String, author: String, body: String, comments: [&#123; body: String, date: Date &#125;], date: &#123; type: Date, default: Date.now &#125;, hidden: Boolean, meta: &#123; votes: Number, favs: Number &#125;&#125;); 小栗子1234567891011121314151617181920var mongoose = require('mongoose')var Schema = mongoose.Schema//连接数据库 //指定链接的的数据库不需要存在，当你插入第一条数据后就会被自动创建出来mongoose.connect('mongodb://localhost:27017/itcast');//设计文档结构（表结构）var userSchema = new Schema(&#123; username: &#123; type: String, require: true //表示必须有 &#125;, password: &#123; type: String, require: true &#125;, email: &#123; type: String &#125;&#125;) 将文档结构发布为模型 mongoose.model() 是用来讲一个架构发布为model的 第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称，mongoose会自动将大写单数名词字符串 生成 小写复数 的集合名称 例如这里的 User =&gt; users集合名称 第二个参数：架构的名称 返回值 模型构造函数 var User = mongoose.model(‘User’, userSchema) 增加数据 先new 一个数据对象 使用模型.save（）添加 12345678910111213var admin = new User(&#123; username: 'zx', password: '321', email: 'zx@ad.com'&#125;)admin.save(function(err,ret) &#123; if (err) &#123; console.log('保存失败'); &#125; else &#123; console.log('保存成功'); console.log(ret); &#125;&#125;) 查询 12345678910111213141516171819202122232425262728293031User.find(function (err,ret) &#123; //查询所有 if (err) &#123; console.log('查询失败'); &#125; else &#123; console.log(ret) &#125;&#125;)User.find(&#123; //按条件查询 第一个参数 放入一个 对象 \"条件\" 即可 username: 'zx' &#125;, function (err, ret) &#123; if (err) &#123; console.log('查询失败'); &#125; else &#123; console.log(ret) &#125; &#125;)ps ：find() 无论 怎样都会返回一个数组User.findOne(&#123; //插入条件后 只会返回一个对象，如果没有条件默认返回第一条数据 username: 'zx' &#125;, function (err,ret) &#123; if (err) &#123; console.log('查询失败'); &#125; else &#123; console.log(ret); &#125; &#125;) 更新数据 1234567891011121314User.findByIdAndUpdate( '5c2f01c67677e410308a223a', &#123; username: 'updata后的admin', password: '666666' &#125;, function (err, ret) &#123; if (err) &#123; console.log('更新失败'); &#125; else &#123; console.log('更新成功'); console.log(ret);// 这里是返回更新前的对象内容 &#125; &#125;) 删除数据 1234567891011User.remove(&#123; username: 'zx' &#125;, function (err, ret) &#123; if (err) &#123; console.log('失败'); &#125; else &#123; console.log('成功'); console.log(ret); &#125; &#125;) 附赠 mysql npm i –S mysql //下载包 1234567891011121314151617181920212223242526var mysql = require('mysql');// 1. 创建连接var connection = mysql.createConnection(&#123; host: 'localhost', user: 'root', password: 'root', database: 'users' // 数据库名字&#125;);// 2. 连接数据库 打开冰箱门connection.connect();// 3. 执行数据操作 把大象放到冰箱connection.query('SELECT * FROM `users`', function (error, results, fields) &#123; if (error) throw error; console.log('The solution is: ', results);&#125;);// connection.query('INSERT INTO users VALUES(NULL, \"admin\", \"123456\")', function (error, results, fields) &#123;// if (error) throw error;// console.log('The solution is: ', results);// &#125;);// 4. 关闭连接 关闭冰箱门connection.end();","categories":[{"name":"《数据库》","slug":"《数据库》","permalink":"https://www.ruoduan.top/categories/《数据库》/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.ruoduan.top/tags/数据库/"}]},{"title":"npm-常用命令及切换源","slug":"npm-常用命令及切换源","date":"2018-12-26T14:58:41.000Z","updated":"2018-12-26T15:04:46.118Z","comments":true,"path":"2018/12/26/npm-常用命令及切换源/","link":"","permalink":"https://www.ruoduan.top/2018/12/26/npm-常用命令及切换源/","excerpt":"","text":"npm node package manager——网站 npmjs.com 只要安装了node 就安装了 npm nm也有版本概念 123npm --version //查看版本号npm install --global npm //升级npm版本 一些常用命令 npm init //生成package.json 文件 npm init -y //快速生成 跳过向导 npm install 包名 //下载 npm install //一次性把package.json 中的dependencies 依赖项全部安装 npm install –save //下载并保持依赖项目到package.json 中的dependencies 简写 npm i -S包名 npm uninstall 包名 //只删除 如果有依赖项 依然保存 npm uninstall –save //删除 同时也会把依赖信息也删除 简写 npm un -S 包名 npm –help //查看使用帮助 npm 命令 –help //查看具体使用帮助 例如 npm uninstall –help 1234npm uninstall [&lt;@scope&gt;/]&lt;pkg&gt;[@&lt;version&gt;]... [--save-prod|--save-dev|--save-optional] [--no-save]aliases: un, unlink, remove, rm, r ## alias 别名 具体 命令 请参考 npm切换源，解决 npm 被墙问题当使用官方npm源安装各种包比较慢的时候，建议修改npm源地址 查看npm源地址，在终端输入以下命令 npm config list 会看到官方的npm源 1metrics-registry = &quot;https://registry.npmjs.org/&quot; 国内常用的镜像地址如淘宝npm：https://registry.npm.taobao.org/ 修改registry地址很简单，在终端输入 npm set registry https://registry.npm.taobao.org/ 如果有一天你肉身FQ到国外，用不上了，用rm命令删掉它 npm config rm registry 如果某一天你又被遣送回国了，还是得加上它…… 有些大公司还需要在公司的私有npm源和外部npm源之间来回切换，这样set来rm去不是办法，于是有了nrm nrm是专门用来管理和快速切换私人配置的registry 建议全局安装 npm install nrm -g –save nrm有一些默认配置，用nrm ls命令查看默认配置，带*号即为当前使用的配置 nrm ls 也可以直接输入以下命令查看当前使用的是哪个源 nrm current 切到源http://r.cnpmjs.org/，命令：nrm use 源的别名，即 nrm use cnpm 执行成功提示 1Registry has been set to: http://r.cnpmjs.org/ 用nrm add 命令添加公司私有npm源，如http://registry.npm.360.org(随便写的)，起个别名叫qihoo nrm add qihoo http://registry.npm.360.org 接着查看nrm配置，发现最底部qihoo添加成功 添加完了可以顺便测试下速度（只能测试已添加的源的别名，直接测试源URL是没有前途的），因为我随便写的地址，就测试一下官方的好了 nrm test npm 输出： npm —- 1547ms 是挺慢的。 最后，如果你被公司开除了，怒删公司npm源配置 nrm del qihoo","categories":[{"name":"《Nodejs》","slug":"《Nodejs》","permalink":"https://www.ruoduan.top/categories/《Nodejs》/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.ruoduan.top/tags/Nodejs/"}]},{"title":"JavaScript原型，原型链，继承","slug":"JavaScript原型，原型链，继承","date":"2018-11-26T06:21:46.000Z","updated":"2019-01-12T08:41:20.915Z","comments":true,"path":"2018/11/26/JavaScript原型，原型链，继承/","link":"","permalink":"https://www.ruoduan.top/2018/11/26/JavaScript原型，原型链，继承/","excerpt":"","text":"原型 原型的作用：1、通过原型来添加方法，解决数据共享，节省内存空间2、作用于继承，模拟面向对象，来做到继承，多态 构造函数 1234function Person(name,age) &#123; this.name=name; this.age=age; &#125;; 通过原型添加方法： 123Person.prototype.eat=function () &#123; console.log(\"吃饭\"); &#125;; 实例化对象： 12var per1=new Person(\"小明\",\"18\");var per2=new Person(\"小红\",\"20\"); 接下来就是我们所要探讨的了，per1和per2的eat的这个方法是不是同一个方法呢？我们来验证一下： 123console.log(per1.eat==per2.eat);//true​```js结果是true 我们来查看一下他们的结构console.dir(per1);console.dir(per2); 结论：我们可以看到在Person结构目录下他们都有age和name属性，同时他们也都有 _ proto _ 这个属性，_ proto _ 下面我们看到了又eat这个方法了，这样做到了简单的数据共享了，至于后面的constructor和_ proto _: Object是有关于 原型链和继承；请看下文，我们继续深入 我们虽然做到了同一个构造函数内共享方法且节省了内存空间，但是这并不是我们的真正目的 下面我们再来一个构造函数 12345function Student(name,age,sex) &#123; this.name=name; this.age=age; this.sex=sex; &#125; 为原型添加方法 123Student.prototype.study=function () &#123; console.log(\"学习\"); &#125;; 实例化Student对象 1var stu=new Student(\"小红\",17,\"女\"); 那么问题来了如何让stu可以访问per的方法呢？答案是可以的我们可以通过改变Student的原型指向来做到 1234Student.prototype=new Person(\"小明\",\"18\")；输出一下，用stu去访问Person的方法stu.eat;//吃饭 通过改变原型的指向我们可以去访问别的构造函数的方法但是这样做涌现出来一个问题，那就是通过改变原型指向后，Student没办法访问自己的原本的方法study了 12console.log(stu.study);//undefinedstu.study();// 报错 为什么会出现这个问题呢？让我们想一下，我们是先给Student添加的原型指向然后才改变的原型指向，Student的原型指向本来是study，但是之后又被指向了new Person，所以自然Student的原型方法study被架空了，如果我们换个方式来写，先给Student改变原型指向，再添加方法这样的话study这个方法就不会被架空了 我把代码重新集中一下（方便阅读） 12345678910111213141516//人的构造函数 function Person(age) &#123; this.age=10; &#125; //人的原型对象方法 Person.prototype.eat=function () &#123; console.log(\"人\"); &#125;; //学生的构造函数 function Student() &#123; &#125; Student.prototype=new Person(10); Student.prototype.sayHi=function () &#123; console.log(\"学生\"); &#125;; 输出： 12stu.eat(); //人stu.sayHi(); //学生 查看结构：console.dir(stu); 于是推出以下结论 当调用某种方法或查找某种属性时，首先会在自身调用和查找，如果自身并没有该属性或方法，则会去它的_ proto _属性中调用查找，也就是它构造函数的prototype中调用查找附一张原型截个图（图片来自于网络） 继承其实上面那种方式就继承中的其中一种——原型继承了；为什么要到现在才说呢，就是为了结合继承对原型的理解更加深入更加易于理解，下面我将继续阐述几种继承并指出他们的优缺点和相应的案例 构造继承核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 1234567891011function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125; // Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 解决了1中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call多个父类对象） 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 实例继承 核心：为父类实例添加新特性，作为子类实例返回123456789101112function Cat(name)&#123; var instance = new Animal(); instance.name = name || 'Tom'; return instance;&#125; // Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 特点： 不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果 缺点： 实例是父类的实例，不是子类的实例 不支持多继承 拷贝继承 1234567891011121314151617181920212223242526272829 var obj1=&#123; name:10, age:\"女\", sleep:function () &#123; console.log(\"睡觉\") &#125; &#125;; //改变了地址指向 var obj2=obj1; console.log(obj2.name,obj2.age,); obj2.sleep();//这个拷贝只是改变了栈的指向//而下面方法，是把堆里面的属性和方法复制一份重新开了一个空间function Cat(name)&#123; var animal = new Animal(); for(var p in animal)&#123; Cat.prototype[p] = animal[p]; &#125; Cat.prototype.name = name || 'Tom';&#125; // Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // tru 特点： 支持多继承 缺点： 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 组合继承（常用的继承方式）核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 12345678910111213141516171819202122232425//原型实现继承 //借用构造函数实现继承 //组合继承:原型继承+借用构造函数继承 function Person(name,age,sex) &#123; this.name=name; this.age=age; this.sex=sex; &#125;; Person.prototype.sayHi=function () &#123; console.log(\"人的打招呼\"); &#125;; function Student(name,age,sex,score) &#123; //借用构造函数:属性值重复的问题 Person.call(this,name,age,sex) this.score=score; &#125;; //改变原型指向----继承 Student.prototype=new Person();//不传值 Student.prototype.eat=function () &#123; console.log(\"学生的吃原型\"); &#125;; var stu1=new Student(\"小明\",\"18\",\"男\",\"100\"); console.log(stu1.name,stu1.age,stu1.sex,stu1.score);//小明 18 男 100 stu1.sayHi();//人的打招呼 stu1.eat();//学生的吃原型 特点： 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 既是子类的实例，也是父类的实例 不存在引用属性共享问题 可传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 123456789101112131415161718function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)(); // Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true 特点： 堪称完美 缺点： 实现较为复杂 附一点题外话： 面向对象编程思想:根据需求,分析对象,找到对象有什么特征和行为,通过代码的方式来实现需求,要想实现这个需求,就要创建对象,要想创建对象,就应该显示有构造函数,然后通过构造函数来创建对象.,通过对象调用属性和方法来实现相应的功能及需求,即可 首先JS不是一门面向对象的语言,JS是一门基于对象的语言,那么为什么学习js还要学习面向对象,因为面向对象的思想适合于人的想法,编程起来会更加的方便,及后期的维护…. 面向对象的编程语言中有类(class)的概念(也是一种特殊的数据类型),但是JS不是面向对象的语言,所以,JS中没有类(class),但是JS可以模拟面向对象的思想编程,JS中会通过构造函数来模拟类的概念(class) 所有引用类型（函数，数组，对象）都拥有proto属性（隐式原型） 所有函数拥有prototype属性（显式原型）（仅限函数） 原型对象：拥有prototype属性的对象，在定义函数时就被创建","categories":[{"name":"《ECMA JavaScript》","slug":"《ECMA-JavaScript》","permalink":"https://www.ruoduan.top/categories/《ECMA-JavaScript》/"}],"tags":[{"name":"ECMA-JavaScript","slug":"ECMA-JavaScript","permalink":"https://www.ruoduan.top/tags/ECMA-JavaScript/"}]},{"title":"VUE-why-components-data-must-be-a-function","slug":"VUE-components-data","date":"2018-11-15T07:06:59.670Z","updated":"2018-11-26T06:32:34.182Z","comments":true,"path":"2018/11/15/VUE-components-data/","link":"","permalink":"https://www.ruoduan.top/2018/11/15/VUE-components-data/","excerpt":"","text":"话不多说上代码测试： 定义一个全局组件，绑定msg 我们首先看如果把data的值外传不在组件里面创建的效果 12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt; &lt;div id=\"app\"&gt; &lt;counter&gt;&lt;/counter&gt; &lt;hr&gt; &lt;counter&gt;&lt;/counter&gt; &lt;hr&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; &lt;template id=\"temp\"&gt; &lt;div&gt; &lt;input type=\"button\" value=\"加一\" @click='increment'&gt; &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var dataObj=&#123;count:0&#125; Vue.component('counter',&#123; template:'#temp', data:()=&gt;&#123; return dataObj &#125;, methods:&#123; increment() &#123; this.count++ &#125; &#125; &#125;) var vm=new Vue(&#123; el:'#app', data:&#123;&#125;, methods:&#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;.GIF 现在把dataObj注释， return {count:0} 123456789101112//var dataObj=&#123;count:0&#125; Vue.component('counter',&#123; template:'#temp', data:()=&gt;&#123; return &#123;count:0&#125; &#125;, methods:&#123; increment() &#123; this.count++ &#125; &#125; &#125;) ​ 总结： 不难看出，这里的关键点就在于 return {} 这个地方 如果是作用域外传入对象的话，上面三个组件的click方法都是处理的这个外部对象里面的count，所以他们作用于同样一个变量，但是如果是 return {count : 0}的话是写在template 内部的，所以每当你在page上渲染一个组件就会响应的创建一个count ，所以他们互不干预，在事件使用中我们可以根据这个小小的点实现不同需求的功能而省去多余的代码","categories":[{"name":"《VUE》","slug":"《VUE》","permalink":"https://www.ruoduan.top/categories/《VUE》/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://www.ruoduan.top/tags/VUE/"}]},{"title":"Hello-User","slug":"Hello-User","date":"2018-11-09T10:21:07.000Z","updated":"2019-01-12T08:52:03.457Z","comments":true,"path":"2018/11/09/Hello-User/","link":"","permalink":"https://www.ruoduan.top/2018/11/09/Hello-User/","excerpt":"","text":"Hello User​ 欢迎来到我的blog主页，前端初探者一名，且在前端的路上在不断的学习和实践，有同样志同道合的朋友，或者发现本人博客有什么地方写的有错误和瑕疵，可以点击右边的E-mail，给我来信，欢迎一起学习，交流 ！ 其实世事并无好坏，全看你们如何去想。(There is nothing either good or bad, but thinking makes it so.) ​ ——威廉·莎士比亚《哈姆雷特》","categories":[{"name":"《记》","slug":"《记》","permalink":"https://www.ruoduan.top/categories/《记》/"}],"tags":[{"name":"记","slug":"记","permalink":"https://www.ruoduan.top/tags/记/"}]}]}